{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to the Bashlib Homepage.</p> <p>The documentation here is still incomplete both in content and structure, so feel free to open a discussion about things you want to see added. While we try to update this documentation together with updates in the code, it is always possible we miss something, so please report it if you find incorrect information or links that no longer work.</p> <p>An introductory tutorial can be found here. This is a good way to get started with the server and its setup.</p>"},{"location":"tutorial/","title":"Bashlib Tutorial - CLI edition","text":"<p>This tutorial aims to teach the basics of the Solid Bashlib library. This tutorial only regards the CLI interface of the Bashlib library. For the Node.JS interface, please look at the Bashlib tutorial - Node.JS edition!</p> <p>Used aliases in this document: All aliases are calculated from the root of the cloned bashlib repo.   - bashlib-css  - <code>alias bashlib-css=\"node bin/solid-dev.js\"</code>   - bashlib-solid  - <code>alias bashlib-solid=\"node bin/solid.js\"</code>   - bashlib-auth - <code>alias bashlib-auth=\"node bin/solid.js --auth token -t .tokens/.bobs-auth-token\"</code> Feel free to use a different authentication scheme for the <code>bashlib-auth</code> alias.</p>"},{"location":"tutorial/#index","title":"Index","text":"<ul> <li>Bashlib Tutorial - CLI edition</li> <li>Index</li> <li>Setting up a Solid Server</li> <li>Setting up Bashlib</li> <li>Bashlib-css<ul> <li>Creating a new Solid account + data pod</li> <li>Creating a Client Credentials token</li> <li>Authentication options</li> </ul> </li> <li>Bashlib-solid<ul> <li>Authentication</li> <li>Authenticate using Client Credentials token</li> <li>Interactive authentication</li> <li>No authentication</li> <li>Commands</li> <li>URL Prefixes</li> <li>fetch / cat</li> <li>list / ls</li> <li>copy / cp</li> <li>move / mv</li> <li>remove / rm</li> <li>mkdir</li> <li>touch</li> <li>find</li> <li>query</li> <li>perms</li> <li>edit</li> </ul> </li> <li>Examples<ul> <li>Creating a new pod and authentication token</li> <li>Setting up a profile image on your pod</li> </ul> </li> </ul>"},{"location":"tutorial/#setting-up-a-solid-server","title":"Setting up a Solid Server","text":"<p>Before we use the Bashlib library, we need a Solid account and accompanying data pod to use the library. In case you already own a Solid pod, you may still want to follow the setup process, as some of the functionality will only be available for pods created on a Community Solid Server instance.</p> <p>To set up a Solid Server where we can register an account and get an accompanying data pod, we will make use in this tutorial of the Community Solid Server. </p> <p>To set up a local Community Solid Server instance, please execute the code below. More information on the setup process can be found here. When you are done with the tutorial, you can remove the current folder to delete all created files.</p> <pre><code>git clone https://github.com/CommunitySolidServer/CommunitySolidServer.git\ncd CommunitySolidServer/\nnpm install\nnpm start\n</code></pre> <p>Congratulations! Your own CSS instance is now running on localhost on port 2323.  You can confirm this by browsing to <code>http://localhost:3000</code> in the browser, and you will be greeted with a setup screen. You do not have to do anything on this screen for now! </p>"},{"location":"tutorial/#setting-up-bashlib","title":"Setting up Bashlib","text":"<p>To set up the <code>Bashlib</code> library, we execute the following code: <pre><code>git clone https://github.com/SolidLabResearch/Bashlib.git\ncd Bashlib\nnpm install\nnpm run build\n</code></pre></p> <p>This code does the setup for Bashlib, and installs the available modules. Your <code>Bashlib</code> library is now set up and ready to use!</p>"},{"location":"tutorial/#bashlib-css","title":"Bashlib-css","text":"<p>To start with <code>Bashlib</code>, we first take a look at the <code>Bashlib-css</code> module. This module gives a set of functions specifically designed for the Community Solid Server.  It handles functionality that is currently not included in the spec for Solid and may vary between implementations of the Solid specification. The CLI interface for <code>Bashlib-css</code> can be accessed here: <pre><code>node bin/solid-dev.js\n</code></pre> optional: You can create an alias for this path so you do not have to write the full command every time. From here on, I will assume the alias <code>alias bashlib-css=\"node bin/solid-dev.js\"</code> to be set!</p>"},{"location":"tutorial/#creating-a-new-solid-account-data-pod","title":"Creating a new Solid account + data pod","text":"<p>compatbility: CSSv2.0.0 - current</p> <p>A first function of the <code>Bashlib-css</code> module is the creation of a new Solid-account and accompanying data pod on a CSS instance. This serves as an alternative to having to use the browser interface to register a new user; which can be found on http://localhost:3000/idp/register/.</p> <p>To create a new Solid account and pod, please execute the following code: <pre><code>bashlib-css create-pod \n</code></pre> An interactive prompt will be shown, requiring you to enter the information of your to-be-created Solid account.</p> <p>e.g.  <pre><code>? CSS instance base url   http://localhost:3000/\n? Pod and user name       Bob\n? User email              bob@test.edu\n? User password           bobIsTheBest123 \n</code></pre> This will result in the message that a pod for bob has been created succesfully on http://localhost:3000/bob/profile/card#me. If you navigate to this URL, you can now see the profile document of the newly created Solid account on the newly created Solid pod.</p> <p>If you do not want an interactive prompt, you can use the command with all options enabled  <pre><code>bashlib-css create-pod -u \"http://localhost:3000/\" -n Carol -e carol@test.edu -p carolIsTheBest123\n</code></pre> to automatically create a new pod without requiring manual interaction.</p>"},{"location":"tutorial/#bashlib-solid","title":"Bashlib-solid","text":"<p>The <code>Bashlib-solid</code> module provides a set of functions to facilitate usage of and development for Solid from Node.JS and the CLI. The CLI interface for <code>Bashlib-solid</code> can be accessed here: <pre><code>node bin/solid.js\n</code></pre> optional: You can create an alias for this path so you do not have to write the full command every time. From here on, I will assume the alias <code>alias bashlib-solid=\"node bin/solid.js\"</code> to be set!</p>"},{"location":"tutorial/#authentication","title":"Authentication","text":"<p>We will quickly go over the available authentication options:</p>"},{"location":"tutorial/#cli-authentication","title":"CLI Authentication","text":"<p>compatbility: CSSv4.0.0 - current</p>"},{"location":"tutorial/#creating-a-client-credentials-token","title":"Creating a Client Credentials token","text":"<p>A first function of the <code>Bashlib-solid</code> module is the creation of a Client Credentials token.  These tokens allow the user to authenticate without requiring user interaction by having them authenticate using a browser window. </p> <p>To create such a token, we can use the <code>create-token</code> command. This coud be for example: <pre><code>bashlib-solid auth create-token\n</code></pre></p>"},{"location":"tutorial/#interactive-authentication","title":"Interactive authentication","text":"<p>compatbility: all</p> <p>An alternative authentication method is the interactive login. This option provides the default Inrupt Node.JS authentication flow, and is compatible with all pods. The interactive authentication requires the user to manually authenticate using their browser. <pre><code> bashlib-solid --auth interactive --idp http://localhost:3000 &lt;command&gt; [options]\n</code></pre> We can now use the authenticated fetch command on private resources: <pre><code>  bashlib-solid --auth interactive --idp http://localhost:3000 fetch http://localhost:3000/bob/profile/\n</code></pre></p>"},{"location":"tutorial/#no-authentication","title":"No authentication","text":"<p>compatbility: all</p> <p>Finally, you can just make use of the library without authenticating yourself. This is the default option when no auth option is specified. <pre><code> bashlib-solid --auth none  &lt;command&gt; [options]\n</code></pre> We can now use fetch public resources as such: <pre><code>  bashlib-solid --auth none fetch http://localhost:3000/bob/profile/card\n</code></pre></p>"},{"location":"tutorial/#commands","title":"Commands","text":"<p>Now that we have created a Solid account and pod and learned how to authenticate, we will look at the available commands in <code>Bashlib-solid</code>. In this section, we will do a runthrough for all available commands, and how they can be used. These commands will help you see solid not only as a Web technology, but as something you can easily include in existing workflows, while enabling ease of access and sharing of resources in between systems and users. We use the alias <code>alias bashlib-auth = \"node bashlib/solid/bin/solid.js --auth token -t .tokens/.bobs-auth-token\"</code> as a shortcut to make authenticated requests from here. In case you use another authentication method feel free to choose your own alias!</p>"},{"location":"tutorial/#url-prefixes","title":"URL Prefixes","text":"<p>All commands support URL prefixes for all URL parameters. Prefixes only work when the user is authenticated! Accepted prefixes are:   - <code>webid:</code>  - The user WebID   - <code>inbox:</code>  - The user inbox (if available)    - <code>root:</code>   - The user storage root (only found if the WebID is inside te data pod)   - <code>base:</code>   - Identical to <code>root:</code></p> <p>For our user bob, we can now write the following url <pre><code>  base:/public/resource1.ttl\n</code></pre> to define the resource located at <pre><code>  http://localhost:3000/bob/public/resource1.ttl\n</code></pre> From here on out, we will make use of the prefixes, so feel free to authenticate with your own data pod, and follow the steps on your own pod environment.</p>"},{"location":"tutorial/#fetch-cat","title":"fetch / cat","text":"<p>The first command is the <code>fetch</code> command, with its twin the <code>cat</code> command. Both commands have an identical result, of fetching and displaying the remote resource to <code>stdout</code>,  but the <code>fetch</code> command can take additional flags to pass custom headers and more.</p> <p>To fetch the user webId, we can now call the following function: <pre><code>  bashlib-auth fetch webid:\n</code></pre> As the authenticated user is Bob (see the alias we created), we just fetched bob's WebID. Additional options can be found by calling the help function. <pre><code>  bashlib-auth fetch --help\n</code></pre> If we want to fetch the file in an other RDF format, we can add custom headers: <pre><code>  bashlib-auth fetch -h \"Accept: application/ld+json\" webid:\n</code></pre></p>"},{"location":"tutorial/#list-ls","title":"list / ls","text":"<p>The <code>list</code> or <code>ls</code> command displays a listing of a container on a Solid pod. The url argument should end in a <code>/</code> as it must be a container. Options can be discovered using the help command. </p> <p>To list the resources in our profile folder, we use the following command: <pre><code>  bashlib-auth ls base:/profile/\n</code></pre></p> <p>By looking at the help function, we now will add the <code>--all</code> flag to also include any .acl files in the directory, and the <code>--long</code> flag to show a table overview of the result</p> <pre><code>  bashlib-auth ls --all --long base:/profile/\n</code></pre>"},{"location":"tutorial/#copy-cp","title":"copy / cp","text":"<p>The <code>copy</code> or <code>cp</code> command copies resources form and to both the local filesystem and a data pod. Make sure you have read permissisons for the source location and write permissions for the destination location when they are on a pod.</p> <p>We will demonstrate the copy command by uploading a profile image form our local disk. If you have chosen a local image file, we can now upload this to our pod as follows: <pre><code> bashlib-auth cp contacts.ttl base:/profile/\n</code></pre> This copies the <code>contacts.ttl</code> file to the container at the url <code>http://localhost:3000/bob/profile/</code>, and creates the contacts.ttl resource in this container. We can now request the copied file as follows: <pre><code> bashlib-auth cat base:/profile/contacts.ttl\n</code></pre> We can also copy resources from one location on our pod to another location as follows: <pre><code> bashlib-auth cp base:/profile/contacts.ttl base:/test/\n</code></pre> and can now fetch the resource at the target location <pre><code> bashlib-auth fetch base:/test/contacts.ttl\n</code></pre> We see that the missing containers were automatically created.</p> <p>Notes: - Directories are always copied recursively as a default. - Copying files without an extension from the data pod will result in $., with the extension value based on the file contenttype. - Copying a file <code>card$.ttl</code> to your data pod will result in a file <code>card</code> with a content type of <code>text/turtle</code>. - Copying a file to a directory will place that file with the given filename in the destination directory. - When directly copying an .acl file, the <code>--all</code> flag must not be set.  - Missing containers are automatically created."},{"location":"tutorial/#move-mv","title":"move / mv","text":"<p>The <code>move</code> or <code>mv</code> command moves resources between different locations on a data pod or between data pods. It is equal to a <code>cp</code> operation followed by a <code>rm</code> operation on the source.  Make sure that the correct permissions are set to read and remove the source resources, and write to the destination resources.</p> <p>In the last section, we made a <code>contacts.ttl</code> resource in our <code>base:/test/</code> container.  We can now move the test resource we just made as a demonstration: <pre><code>bashlib-auth mv base:/test/contacts.ttl base:/test/demo_contacts.ttl\n</code></pre></p>"},{"location":"tutorial/#remove-rm","title":"remove / rm","text":"<p>The <code>remove</code> or <code>rm</code> command removes resources from a data pod.</p> <p>With this command, we can now remove the <code>demo_contacts.ttl</code> file in the <code>/test</code> folder: <pre><code>bashlib-auth rm base:/test/demo_contacts.ttl\n</code></pre> If we now look at the container listing: <pre><code>bashlib-auth ls base:/test/\n</code></pre> we see that the resource has been removed. We can also remove the container now as follows: <pre><code>bashlib-auth rm base:/test/\n</code></pre> To remove a container together with the contained resources, the <code>-r, --recursive</code> flag has to be set.</p>"},{"location":"tutorial/#mkdir","title":"mkdir","text":"<p>The <code>mkdir</code> command creates a target container.</p> <p><pre><code>bashlib-auth mkdir base:/Pictures/\n</code></pre> creates a new <code>Pictures/</code> container in the root of your pod.</p>"},{"location":"tutorial/#touch","title":"touch","text":"<p>The <code>touch</code> command creates a target resource in a container.</p> <p><pre><code>bashlib-auth touch base:/test.txt\n</code></pre> creates a new resource <code>test.txt</code> in the root of your pod.</p>"},{"location":"tutorial/#find","title":"find","text":"<p>The <code>find</code> command enables you to find specific files in a given container based on a given filename regex.</p> <p>If we want to find where our profile card is located on our data pod, we can use the following command: <pre><code>bashlib find --full base: card\n</code></pre> This command looks to match all found files in the <code>base:</code> container with the given filename match <code>card</code>. We use the <code>--full</code> flag to match with and display the full url of the found resources.</p>"},{"location":"tutorial/#query","title":"query","text":"<p>The <code>query</code> command is a convenience command that lets the user query one file or all files in a container based on a given SPARQL query.</p> <p>To return all triples from our WebID, we can use the following command: <pre><code>bashlib-auth query webid: \"Select * WHERE { ?s ?p ?o . }\"\n</code></pre></p> <p>This command also works on containers to recursively query all contained resources. To test this, we first make a new file containing a SPARQL query: <pre><code>echo \"Select * WHERE { ?s ?p ?o . }\" &gt; queryFile.txt\n</code></pre> Now, we can use this query to get all triples of all files on our data pod. We use the <code>--pretty</code> flag to receive the results in a table format: <pre><code>bashlib-auth query -q -p base: queryFile.txt\n</code></pre></p>"},{"location":"tutorial/#perms","title":"perms","text":"<p>The <code>perms</code> command provides three operations to list, edit and delete permissions for a resource on a Solid pod. This command only works for pods implementing the WAC protocols. Pods implementing the ACP protocol (Inrupt) are currently not supported.</p> <p>listing</p> <p>To list the permissions of your profile resource, we can use the following command: <pre><code>bashlib-auth perms list webid:\n</code></pre> Here, we see the permissions written out for all agents, groups and the public for the given resource. This also works for containers. The following command prints the permissions of the pod root in a table format: <pre><code>bashlib-auth perms list --pretty base:\n</code></pre></p> <p>editing note: The editing of permissions for containers and other resources is exactly the same.</p> <p>To demonstrate the editing of permissions, we will first create a <code>Private</code> and <code>Public</code> folder on our pod. <pre><code>bashlib-auth mkdir base:/Private/\nbashlib-auth mkdir base:/Public/\n</code></pre></p> <p>We start by setting the permissions for the <code>base:/Public/</code> container to be publicly readable, and make this the default for all contained resources (only an option for WAC). <pre><code>bashlib-auth perms edit base:/Public/ p=rd\n</code></pre></p> <p>When we now list the resource permissions, we see that public permissions are set to <code>read</code> and <code>default</code>. <pre><code>bashlib-auth perms list --pretty base:/Public/\n</code></pre></p> <p>Now we want to make sure the public cannot read or interact in any way with out <code>Private</code> container. For this we set public permissions to be nothing. However, we want our currently authenticated user to have full permissions in this container and all contained resources as a default (append permissions are implicitly set by giving write permissions): <pre><code>bashlib-auth perms edit base:/Private/ p= u=rwcd\n</code></pre></p> <p>When we now list the resource permissions, we see that no public permissions are set. We also see that the permissions are NOT inherited, meaning they are have been set for the resource successfully. <pre><code>bashlib-auth perms list --pretty base:/Private/\n</code></pre></p> <p>Finally, we want to give permission to our friend with the WebID <code>https://my.friends.pod/profile/card#me</code> to read and write in our <code>Private</code> container. For this we use the following command: <pre><code>bashlib-auth perms edit base:/Private/ https://my.friends.pod/profile/card#me=rw\n</code></pre></p> <p>When we now list the resource permissions, we see that our friend <code>https://my.friends.pod/profile/card#me</code> had received read, write and append (implicitly given through write) permissions over our <code>Private</code> container. <pre><code>bashlib-auth perms list --pretty base:/Private/\n</code></pre></p> <p>deleting Finally, we can also delete resource permissions. We can remove the permissions set for a given resource.</p> <p>To remove the permissions set for the public container, we can use the following command: <pre><code>bashlib-auth perms delete base:/Public/\n</code></pre></p> <p>If we now list the permissions for this container, we see that all current permissions are inherited from the parent container, as the permissions for the <code>Public</code> container have been deleted. <pre><code>bashlib-auth perms list --pretty base:/Public/\n</code></pre></p>"},{"location":"tutorial/#edit","title":"edit","text":"<p>The edit command is a helper command to quickly allow you to edit resources on your pod. The command takes the url of a resource (cannot be a container), copies the resource to your local filesystem and opens the resource with your given or your default editor.</p> <p>We will now edit the file <code>base:/Public/test.txt</code> with our local vim editor.  If you do not have vim installed, please select your prefered editor or do not use the flag to use the default system editor. Using the <code>--touch</code> flag, we will create a new file if the resource does not exist yet. <pre><code>bashlib-auth edit --editor vim --touch base:/Public/test.txt\n</code></pre></p> <p>Now your editor will open with an empty file. You can now edit the file to contain a string of text, and then save the file in your editor. On exiting the editor, and returning to the terminal, you must press any button to continue. Now, the edited resource will be copied from your local filesystem to its location on the data pod, and be removed from the local filesystem.</p> <p>If we now look at the created file <pre><code>bashlib-auth cat base:/Public/test.txt\n</code></pre> we see that the file has been created and contains the text that was written in the editor.</p>"},{"location":"tutorial/#examples","title":"Examples","text":"<p>In this section, we will go over some quick examples of how the CLI interface of <code>Bashlib</code> can be used to do some common tasks. For all examples, we will make use of the following aliases:</p> <ul> <li>bashlib-css - <code>alias bashlib-css=\"node bashlib/css/bin/css.js\"</code></li> <li>bashlib-solid - <code>alias bashlib-auth=\"node bashlib/solid/bin/solid.js\"</code></li> <li>bashlib-auth - <code>alias bashlib-auth=\"node bashlib/solid/bin/solid.js\" --auth &lt;your_preferred_auth_option&gt;</code></li> </ul>"},{"location":"tutorial/#creating-a-new-pod-and-authentication-token","title":"Creating a new pod and authentication token","text":"<p>compatibility CSSv4 - current</p> <p>First, we need to have a Community Solid Server instance running. More info on how to setup a Community Solid Server can be found here.</p> <p>First, we create a new pod on our running CSS instance. For this we run the <code>create-pod</code> command: <pre><code>bashlib-css create-pod \n</code></pre> and we fill in the required information: <pre><code>? CSS instance base url   your CSS server baseURL, e.g. http://localhost:3000/\n? Pod and user name       the name for your pod\n? User email              the email address to login to the pod\n? User password           the password to login to the pod\n</code></pre></p> <p>On completion, you will receive the following message <pre><code>Pod for &lt;name&gt; created succesfully on &lt;baseurl&gt;/&lt;name&gt;/profile/card#me\n</code></pre> This <code>&lt;baseurl&gt;/&lt;name&gt;/profile/card#me</code> is the WebID of your newly created Solid account.</p> <p>Now that we have created a Solid account, we will create an authentication token we can use to authenticate to our pod from the CLI. For this, we use the <code>create-token</code> command. <pre><code>bashlib-css create-token\n</code></pre> and fill in the required information: <pre><code>? Token name        the name of the token e.g. my-cli-auth-token\n? Pod baseuri       your CSS server baseURL, e.g. http://localhost:3000/\n? User email        the email address to login to the pod\n? User password     the password to login to the pod\n? Token location    you can choose a custom location or leave this blank to default to ~/.solid/.css-auth-token\n</code></pre></p> <p>This creates a client-credentials-token you can use to authenticate at the <code>Token location</code> (default is <code>~/.solid/.css-auth-token</code>). With this token, we can now authenticate our commands, such as listing the permissions of our WebID profile resource.</p> <p>In case the default location was used to store the token, we use the following command <pre><code>bashlib-solid --auth \"token\" perms list --pretty webid:\n</code></pre> In case a custom token location was given, we pass the <code>-t</code> flag to indicate where the token can be found: <pre><code>bashlib-solid --auth \"token\" -t &lt;path_to_token&gt; perms list --pretty webid:\n</code></pre></p> <p>You can alias this to have a quick and easy way to use <code>Bashlib</code> from the cli (-t option only required if the default storage location was not used): <pre><code>alias bashlib-auth=`bashlib-solid --auth \"token\" -t &lt;path_to_token&gt;\n</code></pre> From here on, you can use this alias to make all your commands authenticated: <pre><code>bashlib-auth perms list --pretty webid:\n</code></pre></p>"},{"location":"tutorial/#setting-up-a-profile-image-on-your-pod","title":"Setting up a profile image on your pod","text":"<p>Here we will discuss how we can quickly add a profile image to our profile, and store it on our pod. For this, we first need to choose a profile image. Say we have a nice image we want to use for this at <code>~/Pictures/my_nice_picture.png</code>.</p> <p>First, we copy the image to our pod at the location <code>base:/profile/img.png</code>. <pre><code>bashlib-auth cp ~/Pictures/my_nice_picture.png base:/profile/img.png\n</code></pre></p> <p>Next, we will make this image publicly readable, so everyone can see your profile picture. If you do not like this, feel free to only add read permissions for specific WebIDs. <pre><code>bashlib-auth perms edit base:/profile/img.png p=r\n</code></pre></p> <p>With our image uploaded to our pod and made public, we will now have to edit our profile document to link the new profile image to our WebID. <pre><code>bashlib-auth edit webId:\n</code></pre> This will open our profile document in our default editor. We now add the following line to the document (replace <code>imageurl</code> with the url of the newly uploaded image): <pre><code>&lt;#me&gt; &lt;http://xmlns.com/foaf/0.1/img&gt; &lt;imageurl&gt; .\n</code></pre></p> <p>Now save the document, and exit the editor. Press on any key to continue, and your profile document is now updated with a link to your newly added profile image </p> <p>Congratulations, you just set your profile image.</p>"},{"location":"contributing/making-changes/","title":"Pull Requests","text":""},{"location":"documentation/cli-interface/","title":"CLI Interface","text":"<p>All available commands are presented through the CLI interface found in <code>bin/solid.js</code></p> <pre><code>node bin/solid.js command [command_options] &lt;command_args&gt;\n</code></pre>"},{"location":"documentation/cli-interface/#authentication-options","title":"authentication options","text":"<p>In this section we detail the available authentication options in the CLI interface. These make use of the authentication module exposed by Bashlib-css.</p> <p>The interactive auth option opens a browser window that can be used to interacitvely authenticate you through the browser for the given identity provider value. This follows the default Inrupt Node.JS authentication flow. This option stores session information in your filesystem and re-uses a previous session where possible to speed up subsequent commands without requiring re-authentication. A custom port used for the redirect in the authentication flow can be set using environment variables.</p> <p>The token auth option makes use of Client Credentials tokens available for the Community Solid Server as of version 4. The authentication flow using these tokens happens entirely in Node.JS, and requires no browser interaction! This option stores session information in your filesystem and re-uses a previous session where possible to speed up subsequent commands without requiring re-authentication. Information on how to create a Client Credentials token can be found in the create-token module of Bashlib-css. note: This option is only available for Solid-accounts hosted by a Community Solid Server version 4.0.0 and up.</p> <p>The credentials auth option uses client credentials to authenticate the user. It requires a valid email, password and identityprovider value to be given and hijacks the browser login flow used by the Community Solid Server version 2.x.x. When possible, please make use of the token authentication option, as this does not require the user credentials to be stored on the system!  A custom port used for the redirect in the authentication flow can be set using environment variables. note: This option is deprecated, and only supports versions 2.x.x of the Community Solid Server.</p> <p>When failing to authenticate, the program will try to continue unauthenticated.</p>"},{"location":"documentation/cli-interface/#cli-authentication","title":"CLI authentication","text":"<p>Before being able to execute any commands, an authenticated connection needs to be made to the solid pod by uding the auth command</p>"},{"location":"documentation/cli-interface/#auth","title":"auth","text":"<p>Command to edit authentication options for Bashlib.</p> <p>usage <pre><code>node bin/solid.js auth [command] [options]\n</code></pre> commands</p>"},{"location":"documentation/cli-interface/#show","title":"show","text":"<p>Show current authentication settings.</p> <p>usage <pre><code>node bin/solid.js auth show [options]\n</code></pre> options <pre><code>  -p, --pretty     Display current authentication settings in table format \n</code></pre></p>"},{"location":"documentation/cli-interface/#list","title":"list","text":"<p>List available authentication options.</p> <p>usage <pre><code>node bin/solid.js auth list [options]\n</code></pre> options <pre><code>  -p, --pretty     Display available authentication in table format \n</code></pre></p>"},{"location":"documentation/cli-interface/#set","title":"set","text":"<p>Set current authentication option.</p> <p>usage <pre><code>node bin/solid.js auth show [webid]\n</code></pre> options <pre><code>  webid       Set active WebID directly, without requiring manual selection\n</code></pre></p>"},{"location":"documentation/cli-interface/#remove","title":"remove","text":"<p>Removes the authentication information for a specific WebID or for all saved WebIDs.</p> <p>usage <pre><code>node bin/solid.js auth remove [string]\n</code></pre> options <pre><code>  string      webid | all\n</code></pre></p>"},{"location":"documentation/cli-interface/#clear","title":"clear","text":"<p>Clear currently authenticated WebID.</p> <p>usage <pre><code>node bin/solid.js auth clear\n</code></pre></p>"},{"location":"documentation/cli-interface/#create-token","title":"create-token","text":"<p>create authentication token (only for WebIDs hosted on a Community Solid Server v4.0.0 and up).</p> <p>usage <pre><code>node bin/solid.js auth create-token [options]\n</code></pre> options <pre><code>  -b, --base-url &lt;string&gt;  URL of your CSS server\n  -n, --name &lt;string&gt;      Token name\n  -e, --email &lt;string&gt;     User email\n  -p, --password &lt;string&gt;  User password\n  -v, --verbose            Log actions to the CLI\n</code></pre></p>"},{"location":"documentation/cli-interface/#the-config-file","title":"The config file","text":"<p>You can use a config file with the <code>-c, --config &lt;path&gt;</code> option. This config file will be used to autofill any missing authentication options. The config file must adhere to the following format, and may include any of the following options: <pre><code>{\n  auth: \"token\" | \"credentials\" | \"interactive\" | \"none\",\n  idp: \"https://your.pod.identity.provider.org/\",\n  email: \"User email address\",\n  password: \"User password\",\n  tokenStorage: \"/path/of/token/file\",\n  sessionStorage: \"/path/of/session/storage/file\",\n  port: &lt;number&gt;\n  silent: true | false,\n}\n</code></pre> This option is the preferred way to passing user credentials when using credentials based authentication.</p>"},{"location":"documentation/cli-interface/#environment-variables","title":"environment variables","text":"<p>Finally, the environment variables can be used to pass the above authentication options.</p> <pre><code>BASHLIB_AUTH=&lt;auth type&gt; \nBASHLIB_IDP=&lt;identity provider&gt; \nBASHLIB_TOKEN_STORAGE=&lt;client_credentials_token_storage_location&gt;\nBASHLIB_SESSION_STORAGE=&lt;session_info_storage_location&gt;\nBASHLIB_CONFIG=&lt;config_file_location&gt;\nBASHLIB_AUTH_PORT=&lt;number&gt;\n</code></pre>"},{"location":"documentation/cli-interface/#url-prefix-options","title":"URL prefix options","text":"<p>The CLI interface provides some default prefixes you can use in all URL values for all commands.  The prefix is replaced by the found value when running the command.</p> <p><pre><code>webid: (The user's WebID)\nroot: (The root of your data pod - This will not be found when you have a custom WebID that is not in the domain of your Solid pod!)\ninbox: (The user inbox - when available)\n\nexample usage:\nnode bin/solid.js fetch webid:\n</code></pre> Be sure to include the <code>:</code> at the end of the prefix!</p>"},{"location":"documentation/cli-interface/#commands","title":"commands","text":"<p>In this section, all available commands in the CLI interface are listed and explained.</p>"},{"location":"documentation/cli-interface/#fetch-cat","title":"fetch /cat","text":"<p>This command enables authenticated fetching of resources from the CLI.</p> <p>usage <pre><code>node bin/solid.js fetch [options] &lt;url&gt;\n</code></pre> arguments <pre><code>  url                   URL of the file to be fetched\n</code></pre> options <pre><code>  -v, --verbose          Write out full response and all headers\n  -H, --only-headers     Only write out headers\n  -m, --method &lt;string&gt;  GET, POST, PUT, DELETE, ...\n  -b, --body &lt;string&gt;    The request body\n  -F, --file &lt;string&gt;    File containing the request body. Ignored when the --body flag is set.\n  -h, --header &lt;string&gt;  The request header. Multiple headers can be added separately. e.g. -h \"Accept: application/json\" -h \"...\"\n</code></pre></p>"},{"location":"documentation/cli-interface/#list-ls","title":"list / ls","text":"<p>This command lists the resources contained by the url argument. The passed URL should be a container, or the command will fail.</p> <p>The <code>--all</code> flag can be set to include <code>.acl</code> files in the listing. The <code>--long</code> format provides a table of the resources, and indicates the connection between a resources and their <code>.acl</code> files.</p> <p>usage <pre><code>node bin/solid.js list [options] &lt;url&gt;\n</code></pre> arguments <pre><code>  url            URL of the container to be listed\n</code></pre> options <pre><code>  -a, --all      List all resources (includes .acl and .meta resources)\n  -f, --full     List resources with their full uri (defaults to showing only resource name)\n  -l, --long     List in long format\n  -v, --verbose  Log all operations to the CLI\n</code></pre></p>"},{"location":"documentation/cli-interface/#tree","title":"tree","text":"<p>This command gives a recursive overview of the resources contained by the URL argument. The passed URL should be a container, or the command will fail.</p> <p>The <code>--all</code> flag can be set to include <code>.acl</code> files in the listing.</p> <p>usage <pre><code>node bin/solid.js tree [options] &lt;url&gt;\n</code></pre> arguments <pre><code>  url            Base container to construct tree over\n</code></pre> options <pre><code>  -a, --all      List all resources (includes .acl and .meta resources)\n  -f, --full     List resources with their full URL (defaults to showing only resource name)\n  -v, --verbose  Log all operations to the CLI\n</code></pre></p>"},{"location":"documentation/cli-interface/#copy","title":"copy","text":"<p>This command copies files/resources from and to both the local filesystem and solid pods. Both the source and destination arguments can be either a local path or a URL on a solid pod. Resources that cannot be read due to lack of authorization will be ignored, but can be notified using the <code>--verbose</code> flag. Containers/directories are copied recursively by default. The command will return an error when it's trying to copy a container to a file. Copying a file/resource to a container/directory will create a new file in the container/directory with the same name, and overwrite it if it already exists.</p> <p>The <code>--all</code> flag can be set to include <code>.acl</code> files when copying.</p> <p>usage <pre><code>node bin/solid.js copy [options] &lt;source&gt; &lt;destination&gt;\n</code></pre> arguments <pre><code>  src                         File or directory to be copied\n  dst                         Destination to copy file or directory to\n</code></pre> options <pre><code>  -a, --all                   Copy .acl files in recursive directory copies\n  -i, --interactive-override  Interactive confirmation prompt when overriding existing files\n  -n, --no-override           Do not override existing files\n  -v, --verbose               Log all read and write operations to the CLI\n</code></pre></p>"},{"location":"documentation/cli-interface/#move","title":"move","text":"<p>This command moves files/resources from and to both the local filesystem and solid pods. Its functionality is equal to copying the files/resources from the source to the destination, and then removing the source. note: if the source is the local filesystem, files will not be removed, and the command will be identical to a copy. Resources that cannot be read due to lack of authorization will be ignored, but can be notified using the <code>--verbose</code> flag. Containers/directories are always be moved recursively  by default. The command will return an error when it's trying to move a container to a file. Moving a file to a container will create a new file in the container with the same name, and overwrite it if it already exists.</p> <p>The <code>--all</code> flag can be set to include <code>.acl</code> files when moving.</p> <p>usage <pre><code>node bin/solid.js move [options] &lt;url&gt; &lt;query&gt;\n</code></pre> arguments <pre><code>  src            File or directory to be moved\n  dst            Destination of the move\n</code></pre> options <pre><code>  -a, --all                   Move .acl files when moving directories recursively\n  -i, --interactive-override  Interactive confirmation prompt when overriding existing files\n  -n, --no-override           Do not override existing files\n  -v, --verbose               Log all operations to the CLI\n</code></pre></p>"},{"location":"documentation/cli-interface/#remove-rm","title":"remove / rm","text":"<p>This command removes resources from solid environments. Removing a container requires the -r flag to be set to recursively remove resources from containers! This is in contrast to copy and move commands that set this automatically. <code>.acl</code> resources are not explicitly removed by this command. We expect these auxiliary resources to be deleted by the Pod Provider on resource deletion.</p> <p>usage <pre><code>node bin/solid.js remove [options] &lt;urls...&gt;\n</code></pre> arguments <pre><code>  urls             URL's of resources to be listed\n</code></pre> options <pre><code>  -r, --recursive  Recursively removes all files in given container\n  -v, --verbose    Log all operations to the CLI\n</code></pre></p>"},{"location":"documentation/cli-interface/#mkdir","title":"mkdir","text":"<p>This command creates a new empty container on a Solid pod on the given URL. Missing parent containers are created automatically.</p> <p>usage <pre><code>node bin/solid.js mkdir [options] &lt;url&gt;\n</code></pre> arguments <pre><code>  url            URL of the new container to be created\n</code></pre> options <pre><code>  -v, --verbose  Log all operations to the CLI\n</code></pre></p>"},{"location":"documentation/cli-interface/#touch","title":"touch","text":"<p>This command creates a new empty resource on a Solid pod on a given URL.</p> <p>usage <pre><code>node bin/solid.js touch [options] &lt;url&gt;\n</code></pre> arguments <pre><code>  url            URL of the file to be created\n</code></pre> options <pre><code>  -v, --verbose  Log all operations to the CLI\n</code></pre></p>"},{"location":"documentation/cli-interface/#find","title":"find","text":"<p>This command finds the resources contained by the url argument matching the passed string argument. The passed URL should be a container, or the command will fail.</p> <p>The <code>--all</code> flag can be set to include <code>.acl</code> files in the results.</p> <p>usage <pre><code>node bin/solid.js find [options] &lt;url&gt; &lt;match&gt;\n</code></pre> arguments <pre><code>url              URL of the container to start the search\nfilename         Filename to match, processed as JavaScript RegExp(filename) function\n</code></pre> options <pre><code>  -a, --all      Match all resources (includes .acl and .meta resources)\n  -f, --full     Match resources with their full uri (defaults to matching with their relative path compared to the passed URI argument)\n  -v, --verbose  Log all operations to the CLI\n</code></pre></p>"},{"location":"documentation/cli-interface/#query","title":"query","text":"<p>This command queries over the given resource, or recursively over all contained resources in case the given url is a container. The query parameter MUST be a valid SPARQL query. All non-rdf resources will be ignored.</p> <p>The <code>--all</code> flag can be set to include <code>.acl</code> files in the listing. The <code>--full</code> flag will show the full file URL in the returned results, instead of the relative path to the queried container. The <code>--pretty</code> flag will show the results in a table format.</p> <p>usage <pre><code>node bin/solid.js query [options] &lt;url&gt; &lt;query&gt;\n</code></pre> arguments <pre><code>  url              Resource to query; in case of container recursively queries all contained files\n  query            SPARQL query string | file path containing SPARQL query when -q flag is active\n</code></pre> options <pre><code>  -a, --all        Query all resources (includes .acl and .meta resources)\n  -q, --queryfile  Process query parameter as file path of SPARQL query\n  -p, --pretty     Pretty format\n  -f, --full       List resources with their full uri (defaults to showing only relative URI to the passed url argument)\n  -p, --pretty     Return the results in a table format\n  -v, --verbose    Log all operations to the CLI\n</code></pre></p>"},{"location":"documentation/cli-interface/#perms-chmod","title":"perms / chmod","text":"<p>This command enables the listing, editing and removing of resource permisssions. This command only supports <code>Web Access Controls resources (.acl)</code>, and does not support <code>Access Control Policies resources (.acp)</code>. Editing permissions can be done by supplying a set of permissions. These permissions must be formatted according to the description below. note: Editing permissions for a specific WebID or public permissions will remove all prior assigned permissions. E.g. editing permissions to assign read permissions to a WebID will remove prior assigned write permissions!</p> <p>The <code>--pretty</code> flag can be set to display the results in a table format when listing resource permissions and is ignored for other options.</p> <p>usage <pre><code>node bin/solid.js perms [options] &lt;operation&gt; &lt;url&gt; [permissions]\n</code></pre> arguments <pre><code>  operation      list, edit, delete\n  url            Resource URL\n  permissions    Permission operations to edit resource permissions. \n                    Formatted according to id=[d][g][a][c][r][w]. \n                    For public permissions please set id to \"p\". \n                    For the current authenticated user please set id to \"u\".\n                    To set updated permissions as default, please add the [d] option as follows: id=d[g][a][c][r][w]\n                    To indicate the id as a group id, please add the [g] option as follows: id=g[d][a][c][r][w]```\n</code></pre> options <pre><code>  -p, --pretty   Return the results in a table format\n  -v, --verbose  Log all operations to the CLI\n</code></pre> operations <pre><code>list            List the permissions for the current resource\nedit            Edit the permissions for the current resource\nremove          Remove the ACL file for the current resource\n</code></pre> permissions <pre><code>setting public permissions\np=[d][a][c][r][w]\n\nsetting permissions for the currently authenticated webId\nu=[d][a][c][r][w]\n\nsetting permissions for a specific webId\nwebId=[d][a][c][r][w]\n\npermissions options: \n[d] : set as default (will be applied to contained resources recursively unless otherwise specified by the resource ACL).\n[r] : apply read permissions (if this is not set, read permissions are set to false)\n[w] : apply write permissions (if this is not set, write permissions are set to false)\n[a] : apply append permissions (if this is not set, append permissions are set to false)\n[c] : apply control permissions (if this is not set, control permissions are set to false)\n[g] : defines the &lt;webId&gt; as a group id instead of a webId\n\n\nexample: setting default read and write permissions for http://pod.com/bob/profile/card#me on resource https://pod.com/resource results in:\n&gt; node bin/solid.js perms edit https://pod.com/resource http://pod.com/bob/profile/card#me=rwd\n\nexample2: setting personal and public default read access on resource https://pod.com/resource results in:\n&gt; node bin/solid.js perms edit https://pod.com/resource p=rd u=rd\n</code></pre></p>"},{"location":"documentation/cli-interface/#edit","title":"edit","text":"<p>The edit command is a convenient command created to edit resources on your Solid pod locally. The command will default to use the default system <code>$editor</code>.  After editing, the result will be used to overwrite the original resource. Please keep in mind that there is no locking mechanism for multiple users editing the same file simultaneously.</p> <p>The <code>--header</code> flag can be used to pass custom headers when retrieving the resource to e.g. request the resource in a specific RDF format. The <code>--editor</code> flag can be set to specify the path to the executable of the editor to be used.</p> <p>usage <pre><code>node bin/solid.js edit [options] &lt;url&gt;\n</code></pre> arguments <pre><code>  url                                       URL of the file to be edited\n</code></pre> options <pre><code>  -e, --editor &lt;path_to_editor_executable&gt;  Use custom editor\n  -t, --touch                               Create the file if doesn't exist\n  -h, --header &lt;string&gt;                     The request header. Multiple headers can be added separately. These follow the style of CURL. e.g. --header \"Content-Type: application/json\"\n  -v, --verbose                             Log all operations to the CLI\n</code></pre></p>"},{"location":"documentation/typescript-interface/","title":"TypeScript Interface","text":"<p>The commands available for the CLI are nearly all exported as functions by the <code>Bashlib-solid</code> library in Node.JS. For more information on the working of the functions, please look above in the explanation of the CLI commands. </p>"},{"location":"documentation/typescript-interface/#functions","title":"Functions","text":"<p>The following is a list of available functions that are exported by the Node.js library.</p>"},{"location":"documentation/typescript-interface/#list","title":"list","text":"<p>This command lists the resources contained by the url argument. The passed URL should be a container, or the command will fail.</p> <p>The option <code>all</code> can be set to include <code>.acl</code> files in the listing.</p> <p>usage <pre><code>import { list } from \"/install/location\"\n\nlet url = ...                       // container URL\nlet options = {\n// general command options\n  fetch?: typeof globalThis.fetch,  // An (authenticated) fetch function\n  verbose?: boolean,                // Log all operations\n  logger?: Logger,                  // Custom logging object, logs are sent to the terminal if this is left empty\n// options specific to list\n  all?: boolean,                    // Include .acl resources in the listing\n  full?: boolean                    // Return full URL's instead of relative URL's\n}\n\nawait list(url, options)\n</code></pre></p> <p>returns</p> <p>An array of objects of the <code>ResourceInfo</code> interface: <pre><code>ResourceInfo: {\n  url: string,              // the full resource URL\n  relativePath?: string,    // the resource relative URL\n  isDir: boolean,           // flag if directory or not\n  modified?: Date | null,   // last modified date\n  mtime?: number | null,    // last modified date as mtime\n  size?: number | null,     // resource size\n  types?: string[],         // resource types\n  metadata?: ResourceInfo   // resourceInfo of metadata resource\n  acl?: ResourceInfo,       // resourceInfo of .acl resource\n}\n</code></pre></p>"},{"location":"documentation/typescript-interface/#copy","title":"copy","text":"<p>This command copies files/resources from and to both the local filesystem and solid pods. Both the source and destination arguments can be either a local path or a URL on a solid pod. Resources that cannot be read due to lack of authorization will be ignored, but can be notified by setting the <code>verbose</code> option to <code>true</code>. Containers/directories are copied recursively by default. The command will return an error when it's trying to copy a container to a file. Copying a file/resource to a container/directory will create a new file in the container/directory with the same name, and overwrite it if it already exists.</p> <p>usage <pre><code>import { copy } from \"/install/location\"\n\nlet src = ...\nlet dst = ...\n\nlet options = {\n// general command options\n  fetch?: Function,                // an (authenticated) fetch function\n  verbose?: boolean,               // log all operations\n  logger?: Logger                  // Custom logging object, logs are sent to the terminal if this is left empty\n// options specific to copy\n  all?: boolean,                   // include .acl resources in the listing\n  interactiveOverride?: boolean,   // Determine which if the file should be overwritten, using CLI\n  noOverride?: boolean,            // don't override files that already exist\n}\n\nawait copy(src, dst, options)\n</code></pre></p> <p>returns</p> <p><code>copy</code> returns an object with a property <code>source</code>, that consists of a <code>resourceToTransfer</code> object, and a property <code>destination</code>, that consists of a <code>destinationInfo</code> object. Below is some more information about these two objects: <pre><code>let resourcesToTransfer : { \n  files: FileInfo[],            // an array of files that have been copied\n  directories: FileInfo[],      // an array of directories that have been copied\n  aclfiles: FileInfo[]          // an array of .acl files that have been copied\n};\n\nlet destinationInfo : { \n  files: FileInfo[],            // an array of info about the destination of the files that have been copied\n  directories: FileInfo[],      // an array of info about the destination of the directories that have been copied\n  aclfiles: FileInfo[]          // an array of info about the destination of the .acl files that have been copied\n};\n</code></pre></p>"},{"location":"documentation/typescript-interface/#move","title":"move","text":"<p>This command moves files/resources from and to both the local filesystem and solid pods. Its functionality is equal to copying the files/resources from the source to the destination, and then removing the source. note: if the source is the local filesystem, files will not be removed, and the command will be identical to a copy. Resources that cannot be read due to lack of authorization will be ignored, but can be notified setting the <code>verbose</code> option to <code>true</code>. Containers/directories are always be moved recursively  by default. The command will return an error when it's trying to move a container to a file. Moving a file to a container will create a new file in the container with the same name, and overwrite it if it already exists.</p> <p>usage</p> <pre><code>import { move } from \"/install/location\"\n\nlet src = ...\nlet dst = ...\n\nlet options = {\n// general command options\n  fetch?: any,         // an (authenticated) fetch function\n  verbose?: boolean,  // log all operations\n  logger?:            // Custom logging object, logs are sent to the terminal if this is left empty\n// options specific to move\n  all?: boolean,      // include .acl resources in the listing\n} \n\nawait move(src, dst, options)\n</code></pre> <p>returns The command returns when the source has been moved</p>"},{"location":"documentation/typescript-interface/#remove","title":"remove","text":"<p>This command removes resources from solid environments. Removing a container requires the <code>recursive</code> option to be set to <code>true</code> to recursively remove resources from containers! This is in contrast to copy and move commands that set this automatically. <code>.acl</code> resources are not explicitly removed by this command. We expect these auxiliary resources to be deleted by the Pod Provider on resource deletion.</p> <p>usage <pre><code>import { remove } from \"/install/location\"\n\nlet url = ...\n\nlet options = {\n// general command options\n  fetch?: any,          // an (authenticated) fetch function\n  verbose?: boolean,    // log all operations\n  logger?: Logger       // Custom logging object, logs are sent to the terminal if this is left empty\n// options specific to remove\n  recursive?: boolean,  // include .acl resources in the listing\n} \n\nawait remove(url, options)\n</code></pre></p> <p>returns The command reutns when the source has been removed.</p>"},{"location":"documentation/typescript-interface/#makedirectory","title":"makeDirectory","text":"<p>This command creates a new empty container on a Solid pod on the given URL. Missing parent containers are created automatically.</p> <p>usage <pre><code>import { makeDirectory } from \"/install/location\"\n\nlet url = ...\n\nlet options = {\n// general command options\n  fetch?: any,         // an (authenticated) fetch function\n  verbose?: boolean,   // log all operations\n  logger?: Logger      // Custom logging object, logs are sent to the terminal if this is left empty\n} \n\nawait makeDirectory(url, options)\n</code></pre></p> <p>returns</p>"},{"location":"documentation/typescript-interface/#find","title":"find","text":"<p>This command finds the resources contained by the URL argument matching the passed string argument. The passed URL should be a container, or the command will fail.</p> <p>The <code>--all</code> flag can be set to include <code>.acl</code> files in the results.</p> <p>Given a container, the find function will look for all the files that have a matching filename to the provided one.</p> <p>usage <pre><code>import { find } from \"/install/location\"\n\nlet container = ...\nlet filename = ... (string that is converted into a RegEx internally to match filenames)\n\nlet options = {\n// general command options\n  fetch?: any,                 // an (authenticated) fetch function\n  verbose?: boolean,           // log all operations\n  logger?: Logger              // Custom logging object, logs are sent to the terminal if this is left empty\n// options specific to find\n  all?: boolean,               // include .acl resource in search\n  full?: boolean,              // look for name matches in the full resource URL instead of relative\n  listDirectories?: boolean,   // also match container names in find\n} \n\nawait find(url, options)\n</code></pre></p> <p>returns</p> <p><code>find</code> returns an async iterator of FileInfo objects, where the filename of the file matches the <code>filename</code> provided when calling the function. Nothing is returned whan no files are found with a matching name in <code>container</code>. More info about the structure of <code>FileInfo</code> is listed below: <pre><code>type FileInfo = { \n  absolutePath: string, \n  relativePath?: string,\n  directory?: string, \n  contentType?: string,\n  buffer?: Buffer,\n  blob?: Blob,\n  loadFile?: FileLoadingFunction\n}\n</code></pre></p>"},{"location":"documentation/typescript-interface/#query","title":"query","text":"<p>Execute SPARQL queries against resources located at the given URL, either as a single resource or as a collection of resources (the URL will then need to be the location of the container).</p> <p>usage <pre><code>import { query } from \"/install/location\"\n\n\nlet url = ...         // location of the resource(s)\nlet query = ...       // represents a SPARQL query\n\nlet options = {\n// general command options\n  fetch?: any,         // an (authenticated) fetch function\n  verbose?: boolean,  // log all operations\n  logger?: Logger     // Custom logging object, logs are sent to the terminal if this is left empty\n// options specific to query\n  all?: boolean,      // include .acl resources in querying\n\n} \n\nawait query(url, query, options)\n</code></pre></p> <p>returns</p> <p>An async iterator is returned with objects with the properties <code>fileName</code> and <code>bindings</code>. The <code>fileName</code> property contains the URL of the file that was queried.</p> <p>This function uses Comunica query engine under the hood. For more information about the resulting bindings, please consult this page.</p>"},{"location":"documentation/typescript-interface/#perms","title":"perms","text":"<p>These commands only support <code>Web Access Controls resources (.acl)</code>, and don't support <code>Access Control Policies resources (.acp)</code>.</p>"},{"location":"documentation/typescript-interface/#listpermissions","title":"listPermissions","text":"<p>This command enables the listing of resource permisssions. usage <pre><code>import { listPermissions } from \"/install/location\"\n\nlet url = ...\n\nlet options = {\n// general command options\n  fetch?: any,         // an (authenticated) fetch function\n  verbose?: boolean,   // log all operations\n  logger?: Logger      // Custom logging object, logs are sent to the terminal if this is left empty\n} \n\nawait listPermissions(url, options)\n</code></pre></p> <p>returns</p> <p>An object containing the current permissions of the resource URL is returned. This object is of the IPermissinsListing interface, which has the following properties: <pre><code>interface IPermissionListing {\n  access: {\n    agent?: null  | Record&lt;string, Access&gt;,   // the agent ID's that have acces to this resource\n    group?: null  | Record&lt;string, Access&gt;,   // the group ID's that have acces to this resource\n    public?: null | Access                    // the resource has public access\n  },\n  default?: {\n    agent?: null  | AgentAccess,              // the agent ID's that have acces to this resource, inherited from a parent resource\n    group?: null  | Record&lt;string, Access&gt;,   // the group ID's that have acces to this resource, inherited from a parent resource\n    public?: null | Access                    // the resource has public access, inherited from a parent resource\n  }\n  resource?: {\n    agent?: null  | AgentAccess,              // the agent ID's that have acces to this resource, not inherited but explicitely given\n    group?: null  | Record&lt;string, Access&gt;,   // the group ID's that have acces to this resource, not inherited but explicitely given\n    public?: null | Access                    // the resource has public access, not inherited but explicitely given\n  }\n}\n</code></pre></p>"},{"location":"documentation/typescript-interface/#changepermissions","title":"changePermissions","text":"<p>This command enables the editing of resource permisssions. note: Editing permissions for a specific WebID or public permissions will remove all prior assigned permissions. E.g. editing permissions to assign read permissions to a WebID will remove prior assigned write permissions!</p> <p>usage <pre><code>import { changePermissions } from \"/install/location\"\n\nlet url = ...\n\nlet options = {\n// general command options\n  fetch?: any,         // an (authenticated) fetch function\n  verbose?: boolean,  // log all operations\n  logger?: Logger     // Custom logging object, logs are sent to the terminal if this is left empty\n} \n\nlet operations = [ \n  {\n    type: \"agent\" | 'group' | 'public', // type of permission to change\n    id?: string,                        // (type: agent | group) WebID to change permissions for \n    read?: boolean,                     // assign read permissions\n    write?: boolean,                    // assign write permissions\n    append?: boolean,                   // assign append permissions\n    control?: boolean,                  // assign control permissions\n    default?: boolean,                  // set permissions as default\n  }, ...\n]\n\nawait changePermissions(url, operations, options)\n</code></pre></p> <p>returns</p> <p>the function returns if the permissions are changed correctly.</p>"},{"location":"documentation/typescript-interface/#deletepermissions","title":"deletePermissions","text":"<p>This deletes all of the permissions for a specific resource.</p> <p>usage <pre><code>import { deletePermissions } from \"/install/location\"\n\nlet url = ...\n\nlet options = {\n// general command options\n  fetch?: any,         // an (authenticated) fetch function\n  verbose?: boolean,  // log all operations\n  logger?: Logger     // Custom logging object, logs are sent to the terminal if this is left empty\n} \n\nawait deletePermissions(url, options)\n</code></pre></p> <p>returns</p> <p>The function returns of the deletion of the permissions was successful.</p>"},{"location":"documentation/typescript-interface/#generatecsstoken","title":"generateCSSToken","text":"<p>Create an authentication token (only for WebIDs hosted on a Community Solid Server v4.0.0 and up). usage <pre><code>let options = IClientCredentialsTokenGenerationOptions {\n  name: string,\n  email: string,\n  password: string,\n  idp: string,\n  clientCredentialsTokenStorageLocation?: string // Storage location of the output client credentials token.\n}\n\nawait generateCSSToken(options)\n</code></pre></p> <p>returns The generated CSS token ir returned as an object of the CSSToken type:</p> <pre><code>type CSSToken = {\n  id: string,\n  secret: string,\n  controls: any,\n  name: string,\n  idp: string,\n  email: string,\n}\n</code></pre>"},{"location":"documentation/typescript-interface/#authenticatecsstoken","title":"authenticateCSSToken","text":"<p>This function allows you to get authenticated access to a Solid Pod, using the token generated by <code>generateCSSToken</code>.</p> <p>usage <pre><code>import { authenticateCSSToken } from \"/install/location\"\n\nlet token: { \n  id = ...             // user ID generated by generateCSSToken\n  secret = ...         // secret generated by generateCSSToken \n}\n\nlet idp = ...          // identityprovider\n</code></pre></p> <p>returns</p> <p>Information about the current session is returned in the form of an object of the SessionInfo interface: <pre><code>interface SessionInfo {\n  fetch: typeof fetch   // a generic fetch function\n  webId?: string        // WebId of the user\n}\n</code></pre></p>"},{"location":"documentation/typescript-interface/#touch","title":"touch","text":"<p>This function creates a new empty resource on a Solid pod on a given URL.</p> <p>usage <pre><code>import { touch } from \"/install/location\"\n\nlet url = ...          // URL of the new file\n\nlet options = {\n// general command options\n  fetch?: any,         // an (authenticated) fetch function\n  verbose?: boolean,   // log all operations\n  logger?: Logger      // Custom logging object, logs are sent to the terminal if this is left empty\n} \n\nawait touch(url, options)\n</code></pre></p> <p>returns</p> <p>The function returns when the file has been created correctly.</p>"},{"location":"documentation/typescript-interface/#edit","title":"edit","text":"<p>The edit command is a convenient command created to edit resources on your Solid pod locally. The command will default to use the default system editor.  After editing, the result will be used to overwrite the original resource. Please keep in mind that there is no locking mechanism for multiple users editing the same file simultaneously.</p> <p>The <code>editor</code> option can be set to specify the path to the executable of the editor to be used.</p> <p>This command allows you to edit local and remote files.</p> <p>usage <pre><code>import { edit } from \"/install/location\"\n\nlet url = ...\n\nlet options = {\n// general command options\n  fetch?: any,         // an (authenticated) fetch function\n  verbose?: boolean,   // log all operations\n  logger?: Logger      // Custom logging object, logs are sent to the terminal if this is left empty\n// options specific to edit\n  editor?: string,     // path to the executable of the editor to be used\n  touch?: boolean,     // set to true if the resource does not exist yet\n} \n\nawait edit(url, options)\n</code></pre> returns</p> <p>The function returns if the edit was executed correctly.</p>"},{"location":"usage/overview/","title":"Overview Usage","text":""},{"location":"usage/cli/css-specific/","title":"css specific cli","text":""},{"location":"usage/cli/environment-variables/","title":"Environment Variables","text":""},{"location":"usage/cli/example-requests/","title":"Example requests cli","text":""},{"location":"usage/cli/metadata/","title":"Handling metadata","text":""},{"location":"usage/cli/overview/","title":"Overview Usage for CLI","text":""},{"location":"usage/typescript/css-specific/","title":"css specific typescript","text":""},{"location":"usage/typescript/example-requests/","title":"Example requests ts","text":""},{"location":"usage/typescript/metadata/","title":"Handling metadata","text":""},{"location":"usage/typescript/overview/","title":"Overview Usage for TypeScript","text":""}]}